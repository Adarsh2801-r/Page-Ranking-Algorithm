# -*- coding: utf-8 -*-
"""Page Rank.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zI-O5JEdvJgNANbELLoUzGJeU7UEc7Wr
"""

import numpy as np
import pandas as pd
import scipy
from scipy import integrate

# Returns probability transition matrix
def prob_transition_matrix(adj,alpha):
  N = len(adj)
  empty_rows = list(np.where(~adj.any(axis=1))[0])
  for i in empty_rows:
    for j in range(0,N):
      adj[i][j] = 1/N
  
  prob_matrix = adj/adj.sum(axis=1,keepdims=True)
  prob_matrix = prob_matrix * (1-alpha)
  prob_matrix = prob_matrix + alpha/N 

  return prob_matrix

# TAKE INPUT WEB-GRAPH : EDGE LIST
N = int(input("Enter number of nodes : "))
e = int(input("Enter number of edges : "))
adj = np.zeros([N,N])
for i in range(0,e):
  lst = list(map(int,input().split()))
  u = lst[0]
  v = lst[1]
  adj[u,v] = 1

adj

"""# **PAGE - RANK IMPLEMENTATION WITH LINEAR ALGEBRA PACKAGE**

## 1. Without random teleportation (alpha = 0)
"""

# Get probability matrix with alpha = 0 (no random teleportation) from adjacency matrix
prob_matrix=prob_transition_matrix(adj,0) 
prob_matrix

# Calculate left eigen vector 
left_eigen_vector = scipy.linalg.eig(prob_matrix,left=True,right=False)[1][:,0]
left_eigen_vector = (left_eigen_vector / np.sum(left_eigen_vector))
left_eigen_vector

# Return pages ordered by their page rank values
print("Web pages according to rank (largest to smallest) : ")
list((-left_eigen_vector).argsort()[:N])

"""## 2. With random teleportation (alpha = 0.1)"""

# Get probability matrix with alpha = 0.1 (random teleportation) from adjacency matrix
prob_matrix=prob_transition_matrix(adj,0.1) 
prob_matrix

left_eigen_vector = scipy.linalg.eig(prob_matrix,left=True,right=False)[1][:,0]
left_eigen_vector = (left_eigen_vector / np.sum(left_eigen_vector))
left_eigen_vector

print("Web pages according to rank (largest to smallest) : ")
list((-left_eigen_vector).argsort()[:N])

"""# **PAGE - RANK IMPLEMENTATION WITH POWER ITERATION METHOD**

## 1. Without random teleportation (alpha = 0)
## 2. With random teleportation (alpha = 0.1)
"""

# Consider random-surfer starts from state 0
# Initial prob_dist vector : [1,0,0,.......]
x = np.zeros(N)
x[0]=1
P = prob_transition_matrix(adj,0.1)
curr_vec = x
prev_vec = np.ones(N)
cou=0
while True :
  print("x"+str(cou)+":"+str(curr_vec))
  curr_vec = x@P
  if (str(curr_vec) == str(prev_vec)):
    break
  prev_vec = curr_vec
  x = curr_vec
  cou+=1

print("Converged steady state vector : ")
final_prob_vect = curr_vec
final_prob_vect

# Ranking the web pages 
print("Web pages according to rank (largest to smallest) : ")
list((-final_prob_vect).argsort()[:N])

"""## Conclusion
We see that we are getting the steady state vector from power iteration method same as left eigen vector of prob matrix, thereby same ordering/ranking of pages. This validates the correctness of implementation of the algorithm 
"""